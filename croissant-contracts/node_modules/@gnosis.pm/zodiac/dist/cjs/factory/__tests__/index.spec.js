"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const hardhat_1 = require("hardhat");
const contracts_1 = require("../../contracts");
const moduleDeployer_1 = require("../moduleDeployer");
require("@nomiclabs/hardhat-ethers");
const types_1 = require("../types");
const AddressOne = "0x0000000000000000000000000000000000000001";
describe("Factory JS functions ", () => {
    //let newModuleAddress: string;
    let chainId;
    let mockContract;
    const saltNonce = "0x7255";
    const provider = hardhat_1.ethers.provider;
    before(async () => {
        const Mock = await hardhat_1.ethers.getContractFactory("MockContract");
        mockContract = await Mock.deploy();
        chainId = await (await provider.getNetwork()).chainId;
    });
    it("should execute transaction and retrieve expected address ", async () => {
        const [signer] = await hardhat_1.ethers.getSigners();
        const args = {
            values: [
                AddressOne,
                AddressOne,
                AddressOne,
                100,
                180,
                2000,
                100000000,
                1,
            ],
            types: [
                "address",
                "address",
                "address",
                "uint32",
                "uint32",
                "uint32",
                "uint256",
                "uint256",
            ],
        };
        const { transaction: deployTx, expectedModuleAddress } = await (0, moduleDeployer_1.deployAndSetUpModule)(types_1.KnownContracts.REALITY_ETH, args, provider, chainId, saltNonce);
        const transaction = await signer.sendTransaction(deployTx);
        const receipt = await transaction.wait();
        (0, chai_1.expect)(receipt.transactionHash).to.be.a("string");
        (0, chai_1.expect)(receipt.status).to.be.eq(1);
        (0, chai_1.expect)(expectedModuleAddress).to.a("string");
        //newModuleAddress = expectedModuleAddress;
    });
    it("should execute transaction and retrieve expected address when providing the address and ABI directly", async () => {
        const [signer] = await hardhat_1.ethers.getSigners();
        const args = {
            values: [
                AddressOne,
                AddressOne,
                AddressOne,
                100,
                180,
                2000,
                100000000,
                1,
            ],
            types: [
                "address",
                "address",
                "address",
                "uint32",
                "uint32",
                "uint32",
                "uint256",
                "uint256",
            ],
        };
        const chainContracts = contracts_1.ContractAddresses[chainId];
        const masterCopyAddress = chainContracts[types_1.KnownContracts.REALITY_ETH];
        const abi = contracts_1.ContractAbis[types_1.KnownContracts.REALITY_ETH];
        const { transaction: deployTx, expectedModuleAddress } = await (0, moduleDeployer_1.deployAndSetUpCustomModule)(masterCopyAddress, abi, args, provider, chainId, saltNonce);
        const transaction = await signer.sendTransaction(deployTx);
        const receipt = await transaction.wait();
        (0, chai_1.expect)(receipt.transactionHash).to.be.a("string");
        (0, chai_1.expect)(receipt.status).to.be.eq(1);
        (0, chai_1.expect)(expectedModuleAddress).to.a("string");
        //newModuleAddress = expectedModuleAddress;
    });
    it("should retrieve module instance", async () => {
        const module = await (0, moduleDeployer_1.getModuleInstance)(types_1.KnownContracts.REALITY_ETH, mockContract.address, provider);
        await mockContract.givenMethodReturnBool(module.interface.getSighash("owner"), true);
        const owner = await module.owner();
        (0, chai_1.expect)(owner).to.equal("0x0000000000000000000000000000000000000001");
        (0, chai_1.expect)(module).to.be.instanceOf(ethers_1.Contract);
    });
    it("should retrieve factory and module instance", async () => {
        const { moduleFactory, moduleMastercopy } = await (0, moduleDeployer_1.getModuleFactoryAndMasterCopy)(types_1.KnownContracts.REALITY_ETH, provider, chainId);
        (0, chai_1.expect)(moduleFactory).to.be.instanceOf(ethers_1.Contract);
        (0, chai_1.expect)(moduleMastercopy).to.be.instanceOf(ethers_1.Contract);
    });
});
